Architecture

API Gateway (POST /intake) → Lambda (Python) → RDS MySQL
Secrets Manager holds DB creds.

0) Set your lab variables

export AWS_REGION="us-east-1"

#Chewbacca: The Wookiee demands names, not “db1” like a boring droid.
export DB_ID="chewbacca-mysql-11a"
export DB_NAME="lab11"
export DB_USER="admin"
export SECRET_NAME="chewbacca-db-secret-11a"

export LAMBDA_NAME="chewbacca-intake-lambda-11a"
export API_NAME="chewbacca-intake-api-11a"
export STAGE_NAME="prod"

#Chewbacca: Your ALB days are over. Now you suffer with VPC-enabled Lambda.
export LAMBDA_SG_NAME="chewbacca-lambda-sg-11a"
export RDS_SG_NAME="chewbacca-rds-sg-11a"

Verify region:

    aws configure get region

1) Identify Default VPC + subnets

    #Chewbacca: Find the Wookiee’s home (default VPC).
    export VPC_ID="$(aws ec2 describe-vpcs \
      --filters Name=isDefault,Values=true \
      --query "Vpcs[0].VpcId" --output text)"
    
    echo "VPC_ID=$VPC_ID"

Get subnets in default VPC:

    #Chewbacca: Subnets are like Kashyyyk tree branches—pick a few.
    aws ec2 describe-subnets \
      --filters Name=vpc-id,Values="$VPC_ID" \
      --query "Subnets[].{SubnetId:SubnetId,Az:AvailabilityZone,Cidr:CidrBlock,MapPublic:MapPublicIpOnLaunch}" \
      --output table

Pick 2 subnets (prefer different AZs). Store them:

    export SUBNET1="$(aws ec2 describe-subnets --filters Name=vpc-id,Values="$VPC_ID" \
      --query "Subnets[0].SubnetId" --output text)"
    export SUBNET2="$(aws ec2 describe-subnets --filters Name=vpc-id,Values="$VPC_ID" \
      --query "Subnets[1].SubnetId" --output text)"
    
    echo "$SUBNET1 $SUBNET2"

2) Create Security Groups
2A) Lambda SG

    #Chewbacca: Lambda needs a collar. Not for control — for routing.
    export LAMBDA_SG_ID="$(aws ec2 create-security-group \
      --group-name "$LAMBDA_SG_NAME" \
      --description "Lambda SG for Lab 11A" \
      --vpc-id "$VPC_ID" \
      --query "GroupId" --output text)"
    
    echo "LAMBDA_SG_ID=$LAMBDA_SG_ID"

2B) RDS SG

    #Chewbacca: The database is the Millennium Falcon. Only trusted crew allowed.
    export RDS_SG_ID="$(aws ec2 create-security-group \
      --group-name "$RDS_SG_NAME" \
      --description "RDS SG for Lab 11A" \
      --vpc-id "$VPC_ID" \
      --query "GroupId" --output text)"
    
    echo "RDS_SG_ID=$RDS_SG_ID"

Allow MySQL ONLY from Lambda SG:

    #Chewbacca: 3306 opens only for friends. Everyone else gets growled at and then violently humped.
    aws ec2 authorize-security-group-ingress \
      --group-id "$RDS_SG_ID" \
      --ip-permissions "IpProtocol=tcp,FromPort=3306,ToPort=3306,UserIdGroupPairs=[{GroupId=$LAMBDA_SG_ID}]"

Proof:

    aws ec2 describe-security-groups --group-ids "$RDS_SG_ID" \
      --query "SecurityGroups[0].IpPermissions" --output json

One-command “world-open?” check:

    #Chewbacca: If this prints FAIL, the Wookiee is disappointed.
    aws ec2 describe-security-groups --group-ids "$RDS_SG_ID" \
      --query "SecurityGroups[0].IpPermissions[?FromPort==\`3306\` && ToPort==\`3306\`].IpRanges[].CidrIp" \
      --output text | grep -Eq '0\.0\.0\.0/0' && echo FAIL || echo PASS

3) Create RDS MySQL

Note: In default VPC you can still make RDS private (PubliclyAccessible=false). Do that.
Create DB subnet group (using two subnets):

    #Chewbacca: “Subnet group” = Falcon docking permissions.
    aws rds create-db-subnet-group \
      --db-subnet-group-name "chewbacca-dbsubnet-11a" \
      --db-subnet-group-description "Lab 11A subnet group" \
      --subnet-ids "$SUBNET1" "$SUBNET2"

Create DB:

    #Chewbacca: This is where student tears are stored.
    aws rds create-db-instance \
      --db-instance-identifier "$DB_ID" \
      --engine mysql \
      --db-instance-class db.t3.micro \
      --allocated-storage 20 \
      --master-username "$DB_USER" \
      --master-user-password "TEMPORARY_PASSWORD_LIZZO_LUVS_YOU" \
      --vpc-security-group-ids "$RDS_SG_ID" \
      --db-subnet-group-name "chewbacca-dbsubnet-11a" \
      --backup-retention-period 0 \
      --no-publicly-accessible \
      --region "$AWS_REGION"

Wait until available:

    aws rds wait db-instance-available --db-instance-identifier "$DB_ID" --region "$AWS_REGION"
    echo "RDS is available."

Get endpoint:

    export DB_ENDPOINT="$(aws rds describe-db-instances \
      --db-instance-identifier "$DB_ID" \
      --query "DBInstances[0].Endpoint.Address" --output text)"
    
    echo "DB_ENDPOINT=$DB_ENDPOINT"

Verify it’s private:

#Chewbacca: “PubliclyAccessible: False” or the Wookiee rips your arm off.
aws rds describe-db-instances --db-instance-identifier "$DB_ID" \
  --query "DBInstances[0].PubliclyAccessible" --output text

4) Create database + table (one-time)
You need a MySQL client from somewhere that can reach the DB. For Lab 11A, easiest is:
    CloudShell (if it can reach, depends on networking) or
    a temporary EC2 in the VPC or
    your own bastion/VPN setup

Once connected:

    CREATE DATABASE lab11;
    USE lab11;
    
    CREATE TABLE audit_events (
      id VARCHAR(36) PRIMARY KEY,
      ts_utc VARCHAR(30) NOT NULL,
      actor VARCHAR(100) NOT NULL,
      action VARCHAR(50) NOT NULL,
      resource VARCHAR(200) NOT NULL,
      note VARCHAR(500),
      source_ip VARCHAR(60),
      request_id VARCHAR(100)
    );

5) Create Secrets Manager secret for DB creds
Generate a strong password:

    #Chewbacca: strong passwords make Sith cry.
    export DB_PASS="$(aws secretsmanager get-random-password \
      --password-length 24 \
      --exclude-punctuation \
      --query RandomPassword --output text)"

Create secret JSON:

#Chewbacca: Secrets live in Secrets Manager. Not in Terraform comments. Not in Git. Not in your brain.
cat > db_secret.json <<EOF
    {
      "username": "$DB_USER",
      "password": "$DB_PASS",
      "host": "$DB_ENDPOINT",
      "port": 3306,
      "dbname": "$DB_NAME"
    }
    EOF

Create secret:

    export SECRET_ARN="$(aws secretsmanager create-secret \
      --name "$SECRET_NAME" \
      --secret-string file://db_secret.json \
      --query ARN --output text)"
    
    echo "SECRET_ARN=$SECRET_ARN"


Verify:
    aws secretsmanager describe-secret --secret-id "$SECRET_ARN" --output table

6) Create IAM role for Lambda
Create trust policy:

    cat > lambda_trust.json <<'EOF'
    {
      "Version": "2012-10-17",
      "Statement": [{
        "Effect": "Allow",
        "Principal": { "Service": "lambda.amazonaws.com" },
        "Action": "sts:AssumeRole"
      }]
    }
    EOF

Create role:

    #Chewbacca: Give Lambda the keys it needs, not the whole ship.
    export LAMBDA_ROLE_NAME="chewbacca-lambda-role-11a"
    
    export LAMBDA_ROLE_ARN="$(aws iam create-role \
      --role-name "$LAMBDA_ROLE_NAME" \
      --assume-role-policy-document file://lambda_trust.json \
      --query Role.Arn --output text)"
    
    echo "LAMBDA_ROLE_ARN=$LAMBDA_ROLE_ARN"









